\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[hidelinks]{hyperref}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{mathpartir}
\usepackage{macros}

\renewcommand{\labelitemi}{--}

\title{Syntactic regions}
\author{Emmanuel Haucourt \and Samuel Mimram}

\theoremstyle{theorem}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{example}
\newtheorem{example}[theorem]{Example}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

\begin{document}
\maketitle

\section{Programs}
We write~$\B=\set{\Bfalse,\Btrue}$ for the set of \emph{booleans}. We suppose
fixed a set $\variables=\set{x,y,\ldots}$ of \emph{variables} and a
set~$\mutexes=\set{a,b,\ldots}$ of \emph{mutexes}.
% An \emph{expression} $e$ is either
% \begin{itemize}
% \item a variable~$x$,
% \item $\Bfalse$ or $\Btrue$.
% \end{itemize}
An \emph{action} is either
\begin{itemize}
\item $\P a$ or $\V a$, for some $a\in\mutexes$, respectively meaning that the
  mutex~$a$ is taken or released,
\item $\pset x b$ for some $x\in\variables$ and $b\in\B$,
% \item $\pskip$,
% \item $\pdie$ meaning that the program crashes.
\end{itemize}
We write $\actions$ for the set of actions. A \emph{process} is
\[
  P
  \qquad::=\qquad
  A
  \quad|\quad
  \pseq PP
  \quad|\quad
  \por xPP
  \quad|\quad
  \ppar PP
  \quad|\quad
  \ploop xP
\]
with $A\in\actions$.

\section{Program states}
A \emph{program state} is defined as above together with the following
constructions
\[
  P
  \qquad::=\qquad
  \ldots
  \quad|\quad
  \porl P
  \quad|\quad
  \porr P
  \quad|\quad
  \pskip
\]

\section{Operational semantics}
An
\emph{environment} is a function
\[
  \nu:\variables\sqcup\mutexes\to\B
\]
which to every variable associates its value, and to every mutex whether it has
been taken or not ($\Btrue$ means taken). The \emph{initial valuation} $\nu_0$
is such that $\nu_0(x)=\Bfalse$ for every $x\in\variables$ and
$\nu_0(a)=\Bfalse$ for $a\in\mutexes$. We abuse notations and write
$\nu(\Bfalse)=\Bfalse$ and $\nu(\Btrue)=\Btrue$, so that $\nu(e)$ is defined for
any expression~$e$.

The operational semantics is given by evaluating program states in environments,
\ie judgments of the form $\nu\vdash P$ using the following rules:
\[
  \inferrule{\null}{\penv{\nu}{\pset xb}\redto\penv{\nu[x\mapsto b]}{\pskip}}
\]
\[
  \inferrule{\penv\nu P\redto\penv{\nu'}{P'}}{\penv{\nu}{\pseq PQ}\redto\penv{\nu'}{\pseq{P'}{Q}}}
  \qquad
  \inferrule{\penv{\nu'}{Q}\redto\penv{\nu''}{Q'}}{\penv{\nu}{\pseq \pskip Q}\redto\penv{\nu''}{Q'}}
\]
\[
  \inferrule{\nu(x)=\Bfalse}{\penv{\nu}{\por xPQ}\redto\penv{\nu'}{\porl P}}
  \qquad
  \inferrule{\nu(x)=\Btrue}{\penv{\nu}{\por xPQ}\redto\penv{\nu'}{\porr Q}}
\]
\[
  \inferrule{\penv\nu P\redto\penv{\nu'}{P'}}{\penv{\nu}{\porl P}\redto\penv{\nu'}{\porl{P'}}}
  \qquad
  \inferrule{\penv\nu Q\redto\penv{\nu'}{Q'}}{\penv{\nu}{\porr Q}\redto\penv{\nu'}{\porr{Q'}}}
\]
\[
  \inferrule{\null}{\penv{\nu}{\porl\pskip}\redto\penv{\nu}{\pskip}}
  \qquad
  \inferrule{\null}{\penv{\nu}{\porr\pskip}\redto\penv{\nu}{\pskip}}
\]
\[
  \inferrule{\penv\nu P\redto\penv{\nu'}{P'}}{\penv{\nu}{\ppar PQ}\redto\penv{\nu'}{\ppar{P'}{Q}}}
  \qquad
  \inferrule{\penv\nu Q\redto\penv{\nu'}{Q'}}{\penv{\nu}{\ppar PQ}\redto\penv{\nu'}{\ppar{P}{Q'}}}
  \qquad
  \inferrule{\null}{\penv\nu{\ppar\pskip\pskip}\redto\penv\nu\pskip}
\]
\[
  \inferrule{\nu(x)=\Bfalse}{\penv\nu{\pwhile xP}\redto\penv\nu\pskip}
  \qquad
  \inferrule{\nu(x)=\Btrue}{\penv\nu{\pwhile xP}\redto\penv\nu{\pseq{P}{\pwhile xP}}}
\]
etc. (we must close under transitivity...)

% NB: there is no rule for $\pdie$.

\begin{lemma}[Progress]
  For any crash-free program~$P$ and environment~$\nu$, $\penv\nu P$ reduces to
  $\penv{\nu'}{}$.
\end{lemma}

\begin{lemma}[Determinism]
  For a sequential program there is only one possible derivation tree to the
  normal form~$\penv{\nu'}{}$.
\end{lemma}

\begin{example}
  TODO: example of a program: Syracuse
\end{example}

\section{Positions}
A \emph{position} is
\[
  \pi
  \qquad::=\qquad
  \pbot
  \quad|\quad
  \ptop
  \quad|\quad
  \pseql \pi
  \quad|\quad
  \pseqr \pi
  \quad|\quad
  \porl\pi
  \quad|\quad
  \porr\pi
  \quad|\quad
  \ppar \pi\pi
  \quad|\quad
  \ploopl\pi
\]
A position~$\pi$ is \emph{valid} for a program~$P$ when the judgment
$\vpos\pi P$ is derivable by the following rules
\begin{align*}
  &
  \inferrule{\null}{\vpos\pbot P}
  &&
  \inferrule{\null}{\vpos\ptop P}
  &&
  \inferrule{\vpos\pi P}{\vpos{\pseql\pi}{\pseq PQ}}
  &&
  \inferrule{\vpos\pi Q}{\vpos{\pseqr\pi}{\pseq PQ}}
  \\
  &
  \inferrule{\vpos\pi P}{\vpos{\porl\pi}{\por xPQ}}
  &&
  \inferrule{\vpos\pi Q}{\vpos{\porr\pi}{\por xPQ}}
  &&
  \inferrule{\vpos\pi P\\\vpos\rho Q}{\vpos{\ppar\pi\rho}{\ppar PQ}}
  &&
  \inferrule{\vpos\pi P}{\vpos{\ploopl\pi}{\ploop xP}}
\end{align*}

% \begin{remark}
  % For loops, we need to have left and right variant of $+$ position because
  % $\pbot+\pbot$ could be a position on the left or on the right (we could do the
  % same for sequence).
% \end{remark}


% where the judgment $\mpos\pi P$ means that $\pi$ is a \emph{maximal position}
% of~$P$, inferred by the following rules
% \begin{align*}
  % ...
% \end{align*}

% \begin{lemma}
  % $\mpos\pi P$ implies $\vpos\pi P$.
  % \end{lemma}

A valid position~$\pi$ of a program~$P$ induces a program state $\postate\pi P$
defined by
\begin{align*}
  \postate\pbot P&=P
  &
  \postate\ptop P&=\pskip
  &
  \postate{\pseql\pi}{\pseq PQ}&=\pseq{\postate\pi P}Q
  &
  \postate{\pseqr\pi}{\pseq PQ}&=\postate\pi Q
  &
  \ldots
\end{align*}

\begin{lemma}
  A program has a finite number of valid positions.
\end{lemma}

\begin{theorem}
  Given a program~$P$ and an environment~$\nu$, every program state~$P'$ such
  that $\penv\nu P\redto\penv{\nu'}{P'}$ is of the form $P'=\postate\pi P$ for a
  unique valid position~$\pi$ of~$P$.
\end{theorem}

\noindent
A valid position~$\pi$ of~$P$ is \emph{reachable} if
$\penv{\nu_0} P\redto\penv\nu{\postate\pi P}$ for some environment~$\nu$.

\section{Reduction of positions}
We define $\pi\redto\pi'$ by ... (roughly the non-deterministic version of the
reduction of programs)

\begin{lemma}
  If $\penv\nu{\postate\pi P}\redto\penv{\nu'}{\postate{\pi'}P}$ then $\pi\redto\pi'$.
\end{lemma}

\section{The syntactic order}
We write $\leq$ for the smallest congruence on positions such that
$\pbot\leq\pi$ and $\pi\leq\ptop$ for every position~$\pi$.

\begin{lemma}
  For programs without loops, the preorder is a partial order on valid
  positions.
\end{lemma}

\begin{lemma}
  $\pi\leq\rho$ iff $\pi\overset*\redto\rho$.
\end{lemma}

\begin{theorem}
  If $\penv\nu{\postate\pi P}\redto\penv{\nu'}{\postate{\pi'}P}$ then
  $\pi\leq\pi'$.
\end{theorem}

\section{Intervals}
An \emph{interval} is a pair of positions~$\intv\pi\rho$ such that
$\pi\leq\rho$. Such an interval is valid for a program~$P$ when both $\pi$ and
$\rho$ are valid for~$P$. An interval $\intv\pi\rho$ is \emph{included} in an
interval $\intv{\pi'}{\rho'}$ when ... (TODO: be careful for loops)

A \emph{region} of~$P$ is a finite set of valid intervals of~$P$. Two regions
are considered equivalent when they have a common refinement.

\begin{theorem}
  Regions form a boolean algebra.
\end{theorem}
\end{document}
